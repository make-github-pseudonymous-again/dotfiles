#!/usr/bin/env node

import {
	type Locale,
	format,
	addDays,
	addWeeks,
	startOfDay,
	addMonths,
	startOfWeek,
	startOfMonth,
	formatDistance,
	intervalToDuration,
	isAfter,
	isBefore
} from 'date-fns';
import chalk from 'chalk';
import {
	FRESH,
	TIMEZONE_LOCALE_MAP,
	ParsedEvent,
	calendars,
	cacheLoadUrl,
	range,
} from '../lib/events';

const FMT = 'yyyy-MM-dd HH:mm:ss';
const REGEX_URL = /https?:\/\/(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*(), ]|(?:%[0-9a-fA-F][0-9a-fA-F]))+/g;
const EXCLUDED_URLS = [
	'https://g.co/calendar',
];

const _dateTimeFormatResolvedOptions = Intl.DateTimeFormat().resolvedOptions();
const _systemTimeZone = () => _dateTimeFormatResolvedOptions.timeZone;
const _locale = (key: string ) => import(`date-fns/locale/${key}`).then(({default: locale}) => locale);

async function getLocale(key: string): Promise<Locale> {
  return _locale(key).catch(
    (_) => _locale(key.split('-', 1)[0]!)
  ).catch(
    (_) => undefined
  );
}

const locale = await getLocale(TIMEZONE_LOCALE_MAP[_systemTimeZone()]!);
function formatDuration(start: Date, end: Date): string {
	const duration = intervalToDuration({ start, end });
	const parts: string[] = [];

	if (duration.years) parts.push(`${duration.years}y`);
	if (duration.months) parts.push(`${duration.months}m`);
	if (duration.days) parts.push(`${duration.days}d`);
	if (duration.hours) parts.push(`${duration.hours}h`);
	if (duration.minutes) parts.push(`${duration.minutes}m`);

	return parts.length > 0 ? parts.join(' ') : '0m';
}

const now = new Date();
const today = startOfDay(now);
const tomorrow = addDays(today, 1);
const dayAfterTomorrow = addDays(tomorrow, 1);
const startOfThisWeek = startOfWeek(today, {locale});
const nextWeek = addWeeks(startOfThisWeek, 1);
const weekAfterNextWeek = addWeeks(nextWeek, 1);
const startOfThisMonth = startOfMonth(today);
const nextMonth = addMonths(startOfThisMonth, 1);
const monthAfterNextMonth = addMonths(nextMonth, 1);

const allevents = new Set<ParsedEvent>();
const icons: Record<string, string> = {};

for (const calendar of await calendars()) {
	const calendarEvents = await cacheLoadUrl(FRESH, calendar.url);
	calendarEvents.forEach(event => {
		allevents.add(event);
		icons[event.summary] = calendar.icon;
	});
}

const icon = (event: ParsedEvent): string => {
    const summary = event.summary.toLowerCase();

    if (summary.includes('flight')) {
        return '';
    }

    if (['train', 'thalys', 'sncf'].some(keyword => summary.includes(keyword))) {
        return '';
    }

    if (['dentist', 'doctor'].some(keyword => summary.includes(keyword))) {
        return '';
    }

    return icons[event.summary]!;
}


const _fresh = new Set([...allevents].filter(x => isAfter(x.end, now)));

const timesections: [string, Date | null, Date | null][] = [
	["Past", null, today],
	["Today", today, tomorrow],
	["Tomorrow", tomorrow, dayAfterTomorrow],
	["Rest of week", dayAfterTomorrow, nextWeek],
	["Next week", nextWeek, weekAfterNextWeek],
	["Rest of month", weekAfterNextWeek, nextMonth],
	["Next month", nextMonth, monthAfterNextMonth],
	["Future", monthAfterNextMonth, null],
];

const used = new Set<ParsedEvent>();
const sections: [string, Set<ParsedEvent>][] = [];

for (const [summary, begin, end] of timesections) {
	const predicate = (x: ParsedEvent) =>
		(begin === null || isAfter(x.begin, begin)) &&
		(end === null || isBefore(x.begin, end));

	const events = new Set([...(_fresh)].filter(predicate).filter(x => !used.has(x)));

	const A = begin === null ? 'the beginning of the Universe' : format(begin, FMT);
	const B = end === null ? 'the end of the Universe' : format(end, FMT);

	const title = `${summary}, from ${A} to ${B}`;

	sections.push([title, events]);

	events.forEach(event => used.add(event));
}
const _happening = new Set([...(_fresh)].filter(x => isBefore(x.begin, now)));
const _future = new Set([...(_fresh)].filter(x => !_happening.has(x)));

const _current = _happening.size > 0
	? [..._happening].reduce((a, b) => a.end > b.end ? a : b)
	: null;

const _next = _future.size > 0
	? [..._future].reduce((a, b) => a.begin < b.begin ? a : b)
	: null;

let _main: ParsedEvent | null = null;

if (_current === null) {
	if (_next !== null) {
		_main = _next;
	}
} else {
	_main = (_next === null || _next.begin >= _current.end)
		? _current
		: _next;
}

console.log();
console.log(` > Generated on ${format(now, 'EEE, dd MMM yyyy HH:mm:ss zz')}`);

for (const [title, events] of sections) {
	if (events.size === 0) continue;

	console.log();
	console.log(chalk.underline(title));
	console.log();

	const sortedEvents = [...events].sort((a, b) => a.begin.getTime() - b.begin.getTime());

	for (const event of sortedEvents) {
		const {
			summary,
			url,
			location,
			description,
			begin,
			end
		} = event;

		// Assuming begin and end are already in local time
		let eventFormat = isAfter(begin, now)
			? ' {icon}  {range} ({hbegin}) - {summary}'
			: ' {icon}  (started {hbegin}, ends {hend}) - {summary}';

		if (location && !summary.includes(location)) {
			eventFormat += ' ( {location})';
		}

		const urls: string[] = [];

		if (url) urls.push(url);

		if (description && !summary.includes(description)) {
			const matches = description.match(REGEX_URL) || [];
			urls.push(...matches.filter(u => !EXCLUDED_URLS.includes(u)));
		}

		if (urls.length > 0) {
			eventFormat += ' ( {urls[0]})';
		}

		// Apply styling
		if (_main === event) {
			eventFormat = chalk.underline(eventFormat);
		}
		if (_next === event) {
			eventFormat = chalk.yellow(eventFormat);
		}
		if (_current === event) {
			eventFormat = chalk.blue(eventFormat);
		}
		if (_happening.has(event)) {
			eventFormat = chalk.bold(eventFormat);
		}

		const line = eventFormat
			.replace('{icon}', icon(event))
			.replace('{hbegin}', formatDistance(begin, now, { addSuffix: true }))
			.replace('{range}', range(now, begin, end))
			.replace('{hend}', formatDistance(end, now, { addSuffix: true }))
			.replace('{hduration}', `lasts ${formatDuration(begin, end)}`)
			.replace('{summary}', summary)
			.replace('{location}', location || '')
			.replace('{urls[0]}', urls[0] || '');

		console.log(line.replace(/[\r\n]/g, ' '));
	}
}
