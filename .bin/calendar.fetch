#!/usr/bin/env python3

import sys
import os.path
import traceback
import hashlib
import urllib.request
import urllib.error
import arrow
import ics
import json

from events import log
from events import CACHE
from events import calendars
from events import url_hash
from events import dropalarms

try:
    os.makedirs(CACHE.format(''))
except:
    pass

for _calendar in calendars():

    url = _calendar['url']

    try:

        log('downloading {}'.format(url))

        req = urllib.request.Request(
            url,
            data=None,
            headers={
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.47 Safari/537.36'
            }
        )

        data = urllib.request.urlopen(req).read()
        # to check that we can parse the data
        text = data.decode()
        # use workaround for nonrfc valarm blocks (see https://github.com/C4ptainCrunch/ics.py/issues/127)
        text = dropalarms(text)
        calendar = ics.Calendar(text)

        h = url_hash(url)
        filename = CACHE.format(h)

        log('writing {} to {}'.format(url, filename))

        with open(filename, 'w') as fd:
            fd.write(text)

    except urllib.error.URLError as err:

        log('Error opening url: {}'.format(url))
        log(err)
        traceback.print_tb(err.__traceback__, file=sys.stderr)

    except ics.grammar.parse.ParseError as err:

        log('Error parsing file: {}'.format(url))
        log(err)
        traceback.print_tb(err.__traceback__, file=sys.stderr)

    except arrow.parser.ParserError as err:

        log('Error parsing time for {}'.format(url))
        log(err)
        traceback.print_tb(err.__traceback__, file=sys.stderr)

    except FileNotFoundError as err:

        log('Error writing file for {}'.format(url))
        log(err)
        traceback.print_tb(err.__traceback__, file=sys.stderr)

    except Exception as err:

        log('Unknown exception for {}'.format(url))
        log(err)
        traceback.print_tb(err.__traceback__, file=sys.stderr)
