#!/usr/bin/env python3

import os
import sys
import json
import subprocess
from typing import Callable, Iterable, Literal, Optional, Union
from dataclasses import dataclass, asdict
import human
from datetime import datetime, timedelta
from collections import defaultdict

CONFIG = os.path.expanduser('~/.config/commuting/config')

STIBCACHE = os.path.expanduser('~/.cache/stib')
STIBCONFIG = os.path.expanduser('~/.config/stib/config')

STIBHALT = STIBCACHE + '/{}'
STIBLINE = STIBHALT + '/{}'

RTMCACHE = os.path.expanduser('~/.cache/rtm')
RTMCONFIG = os.path.expanduser('~/.config/rtm/config')

RTMHALT = RTMCACHE + '/{}'
RTMLINE = RTMHALT + '/{}'
RTMDEST = RTMLINE + '/{}'
RTMTIME = RTMDEST + '/{}'


log = lambda *x, **y: print(*x, **y, file=sys.stderr)

with open(CONFIG) as _config:
    config = json.load(_config)

with open(STIBCONFIG) as _config:
    stibconfig = json.load(_config)

with open(RTMCONFIG) as _config:
    rtmconfig = json.load(_config)

geolocation = json.loads(subprocess.check_output(
    ['memoize-get', '1200', 'geolocation.fetch']).decode())

def istransit(method: str):
    return method in [ 'train' , 'tram' , 'metro' , 'bus' ]

Method = Union[
    Literal['train'],
    Literal['tram'],
    Literal['metro'],
    Literal['bus'],
]

Vendor = Union[
    Literal['sncb-nmbs'],
    Literal['stib-mivb'],
    Literal['tec'],
    Literal['rtm'],
]

@dataclass(frozen=True)
class Part:
    method: Method
    seconds: Optional[float] = None
    vendor: Optional[Vendor] = None
    halt: Optional[str] = None
    line: Optional[str] = None
    dest: Optional[str] = None
    origin: Optional[str] = None
    destination: Optional[str] = None

def _part(kwargs: dict):
    return Part(**kwargs)


pt = (part for road in config.values() for path in
        road['paths'] for part in
               map(_part, path['path']) if istransit(part.method))


def stibgrab(halt: str, line: str):

    try:

        return sorted(map(datetime.fromisoformat, os.listdir(STIBLINE.format(halt, line))))

    except FileNotFoundError:

        log('no STIB data for', halt, line)

        return []


def rtmgrab(halt: str, line: str, dest: str):

    try:

        return sorted(map(datetime.fromisoformat, os.listdir(RTMDEST.format(halt, line, dest))))

    except FileNotFoundError:

        log('no RTM data for', halt, line, dest)

        return []



def _humanize(time: datetime, ref: datetime):

    return human.datetime(time, ref)


def _duration(delta: timedelta):

    return human.timedelta(delta)



def _shortduration(delta: timedelta):

    return _shorten(_duration(delta))


def _shorthumanize(time: datetime, ref: datetime):

    return _shorten(_humanize(time, ref))

def _tinyduration(delta: timedelta):

    return _tinier(_duration(delta))


def _shorten(x: str):

    if 'minutes' in x or 'seconds' in x:

        return x[:-4]

    if 'minute' in x:

        return x[:-3]

    return x

def _tinier(x: str):

    if 'minutes' in x or 'seconds' in x:

        return x[:-6]

    if 'minute' in x:

        return x[:-5]

    return x


def _repr(path: Iterable[Part], fduration: Callable[[timedelta], str]=_shortduration):

    _map = {
        "wait": lambda part : '  ({})'.format(fduration(timedelta(seconds=part.seconds))),
        "walk": lambda _: '  ',
        "tram": lambda part : {
            "stib-mivb" : lambda part: '  {line}'.format(**part),
            "rtm"       : lambda part: '  {line}'.format(**part),
        }[part['vendor']](part),
        "bus": lambda part: {
            "stib-mivb" : lambda part: '  {line}'.format(**part),
            "rtm"       : lambda part: '  {line}'.format(**part),
            "tec"       : lambda part: '  {line}'.format(**part),
        }[part['vendor']](part),
        "metro": lambda part: {
            "stib-mivb" : lambda part: '  {line}'.format(**part),
            "rtm"       : lambda part: '  {line}'.format(**part),
        }[part['vendor']](part),
        "train": lambda part : {
            "sncb-nmbs" : lambda part: '  {line}'.format(**part),
        }[part['vendor']](part),
    }

    return '  '.join(_map[part.method](part) for part in path)



def _diff(a: datetime, b: datetime):

    return a.timestamp() - b.timestamp()

PT = defaultdict(list)

def _key ( x: Part ) :
    return frozenset( ( k , v ) for k, v in asdict(x).items() if k != 'seconds' )

for part in pt:

    vendor = part.vendor

    if vendor == 'stib-mivb':

        halt = part.halt
        assert(halt is not None)
        line = part.line
        assert(line is not None)

        if halt not in stibconfig or line not in stibconfig[halt]:

            log('warning: stib-mivb is not configured to fetch', halt, line)

        k = _key(part)
        if k not in PT:
            PT[k] = stibgrab(halt, line)

    elif vendor == 'rtm':

        halt = part.halt
        assert(halt is not None)
        line = part.line
        assert(line is not None)
        dest = part.dest
        assert(dest is not None)

        if halt not in rtmconfig or line not in set(x['ref'] for x in rtmconfig[halt]):

            log('warning: rtm is not configured to fetch', halt, line)

        k = _key(part)
        if k not in PT:
            PT[k] = rtmgrab(halt, line, dest)

    else:

        log('warning: unknown vendor ', vendor)


def allroutes():

    for name, road in config.items():

        for path in road['paths']:

            for route in routes(tuple(map(_part, path['path']))):

                yield name, route


def routes(path: tuple[Part, ...], leave=None, total: float=0, prev=()):

    if not path:

        yield leave, total, prev

        return

    if path[0].method == 'walk':

        duration = path[0].seconds

        yield from routes(path[1:], leave, total + duration, prev + ( path[0], ))

    elif _key(path[0]) in PT :

        duration = path[0].seconds
        assert(duration is not None)
        times = PT[_key(path[0])]

        if leave is None:

            for timestamp in times:

                _path = path[1:]
                _leave = timestamp - timedelta(seconds=total)
                _total = total + duration
                _prev = prev + (path[0], )

                yield from routes(_path, _leave, _total, _prev)
        else:

            for timestamp in times:

                waiting = _diff(timestamp, leave) - total

                if waiting < 0:
                    continue

                elif waiting == 0:

                    _path = path[1:]
                    _leave = leave
                    _total = total + duration
                    _prev = prev + (path[0], )

                    yield from routes(_path, _leave, _total, _prev)

                else:

                    _path = path[1:]
                    _leave = leave
                    _total = total + waiting + duration
                    part = {
                        'method' : 'wait',
                        'seconds' : waiting
                    }
                    _prev = prev + (part, path[0])

                    yield from routes(_path, _leave, _total, _prev)

NOW = datetime.now().astimezone()

def _myroutes():
	for name, route in allroutes():

		_leave, _total, _path = route

		if _leave is None:
			_leave = NOW

		elif _leave < NOW:
			continue

		_arrival = _leave + timedelta(seconds=_total)

		yield (name, _path, _leave, _arrival)

myroutes = sorted(_myroutes(), key=lambda x: (x[0], x[3], x[2]))


def myfilter(name):

    for key, value in config[name]['geolocation'].items():

        if not key in geolocation or geolocation[key] != value:

            return False

    if 'days' in config[name] and not NOW.isoformat('%A') in config[name]['days']:

        return False

    return True

for name, _path, _leave, _arrival in myroutes:

    if not myfilter(name):
        continue

    title = config[name]['title']
    leave = _shorthumanize(_leave, NOW)
    arrival = _shorthumanize(_arrival, NOW)
    total = _shortduration(_arrival - _leave)  # remove "in " prefix
    path = _repr(_path)
    eta = _arrival.strftime('%H:%M:%S')

    full_text = ' [{}]  {},  {},  {} :{} : ETA  {}'.format(
        title, leave, total, arrival, path, eta
    )

    sleave = _tinyduration(_leave - NOW)
    sarrival = _tinyduration(_arrival - NOW)
    stotal = _tinyduration(_arrival - _leave)
    spath = _repr(_path,fduration=_tinyduration)

    short_text = ' [{}] {}|{}|{} :{} :  {}'.format(
        title, sleave, stotal, sarrival, spath, eta
    )

    color = "#85bd85"

    if len(_path) > 1:

        d = _diff(_leave, NOW)

        if d < 600:

            if d < 60:

                color = "#CF4647"

            else:

                color = "#F45D4C"

    data = {
        "name"       : "commuting",
        "color"      : color,
        "full_text"  : full_text,
        "short_text" : short_text
    }

    json.dump(data, sys.stdout)
    sys.stdout.write('\n')
